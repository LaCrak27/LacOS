#include "floppy.h"
#include "../kernel/low_level.h"
#include "../kernel/util.h"
#include "screen.h"
#include "../interrupts/idt.h"
#include "timer.h"

// TODO:
//  - Send commands (figure how that all works)
//  - Make it able to R/W
//  - Detect different configs

void FloppyHandler(struct InterruptRegisters *regs);
void send_command(unsigned char cmd, unsigned char arg1, unsigned char arg2, unsigned char arg3, unsigned char arg4, unsigned char arg5, unsigned char arg6);
void reset_controller();
void wait_for_next_param();
void configure(unsigned char impliedSeekEnable, unsigned char fifoDisable, unsigned char drivePollingDisable, unsigned char thresh_val, unsigned char precomp_val);
unsigned char version();
unsigned char lock();
void specify(unsigned char SRT, unsigned char HUT, unsigned char HLT, unsigned char NDMA);
void sense_interrupt(unsigned char *buffer);
void recalibrate();
void readcmd(CHSAddr addr, unsigned char *buffer);

// ASSUMPTIONS FOR NOW:
// - There's a 1.44mb floppy on the master drive, dunno about the slave
// - All floppies are 1.44mb

static char floppyAvailable = FALSE;
static char receivedIRQ = FALSE;

char isFloppyAvailable()
{
    return floppyAvailable;
}

CHSAddr lbatochs(unsigned long lba)
{
    CHSAddr res;
    res.cyl = lba / (2 * FLOPPY_144_SECTORS_PER_TRACK);
    res.head = ((lba % (2 * FLOPPY_144_SECTORS_PER_TRACK)) / FLOPPY_144_SECTORS_PER_TRACK);
    res.sect = ((lba % (2 * FLOPPY_144_SECTORS_PER_TRACK)) % FLOPPY_144_SECTORS_PER_TRACK + 1);
    res.EOT = (res.cyl + 1) * FLOPPY_144_SECTORS_PER_TRACK;
    return res;
}

void initFloppy()
{
    irqInstallHandler(6, &FloppyHandler);
    if (version() != 0x90)
    {
        floppyAvailable = FALSE;
        return;
    }
    // DMA setup
    outb(0x0a, 0x06); // Mask ISA DMA channel 2
    outb(0x0c, 0xFF); // Reset the master flip-flop
    outb(0x04, 0x00); // Address to 0x00 (low unsigned char)
    outb(0x04, 0x80); // Address to 0x80 (high unsigned char), giving start adress 0x8000
    outb(0x0c, 0xFF);
    outb(0x05, 0xFF); // Count to 0xFF (low unsigned char)
    outb(0x05, 0x23); // Count to 0x23 (high unsigned char), giving us a count of 0x23ff (lenght of floppy track - 1)
    outb(0x81, 0x00); // Set page register to 0 (so adress stays 0x8000 + 0x23ff)
    outb(0x0a, 0x02); // Mask channel 2

    configure(1, 0, 1, 8, 0);
    lock();
    reset_controller();
    recalibrate();
    CHSAddr ttt;
    ttt.cyl = 0;
    ttt.EOT = FLOPPY_144_SECTORS_PER_TRACK;
    ttt.head = 0;
    ttt.sect = 0;
    readcmd(ttt, NULL);
    unsigned char *test = 0x8000; 
    println(itoa(*test));
}

// This function gets called when an IRQ6 is generated.
void FloppyHandler(struct InterruptRegisters *regs)
{
    println("IRQ hit!");
    receivedIRQ = TRUE;
}

void reset_controller()
{
    receivedIRQ = FALSE; // This will prevent the FDC from being faster than us!

    // Enter, then exit reset mode.
    outb(DIGITAL_OUTPUT_REGISTER, 0x00); // Enter reset mode
    outb(DIGITAL_OUTPUT_REGISTER, 0x1C); // Drive 0, exit reset, enable IRQs and DMA, turn motor on

    while (!receivedIRQ)
        ; // Wait for the IRQ handler to run

    outb(CONFIGURATION_CONTROL_REGISTER, 0x00); // 500Kbps -- for 1.44M floppy (the only ones we're gonna read)

    // configure the drive
    specify(8, 0, 5, 0); // SRT: 8ms, HUT: MAX, HLT: 10ms, use DMA
    sleep(500);
}

void send_command(unsigned char cmd, unsigned char arg1, unsigned char arg2, unsigned char arg3, unsigned char arg4, unsigned char arg5, unsigned char arg6)
{
    print("Sending command: ");
    println(uitoa(cmd));
cmd_start:
    unsigned char msr;
    // Read MSR
    msr = inb(MAIN_STATUS_REGISTER);

    if (((msr & 0xc0) != 0x80)) // Verify RQM = 1, DIO = 0
    {
        reset_controller();
        goto cmd_start;
    }

    outb(DATA_FIFO, cmd); // Send command to FIFO port

    switch (cmd) // Switch case to get argument
    {
    case CONFIGURE:
        outb(DATA_FIFO, arg1);
        wait_for_next_param();
        outb(DATA_FIFO, arg2);
        wait_for_next_param();
        outb(DATA_FIFO, arg3);
        break;

    case SPECIFY:
        outb(DATA_FIFO, arg1);
        wait_for_next_param();
        outb(DATA_FIFO, arg2);
        break;

    case RECALIBRATE:
        outb(DATA_FIFO, arg1);

    case SEEK:
        outb(DATA_FIFO, arg1);
        wait_for_next_param();
        outb(DATA_FIFO, arg2);
        break;

    case READ_DATA:
        outb(DATA_FIFO, arg1);
        wait_for_next_param();
        outb(DATA_FIFO, arg2);
        wait_for_next_param();
        outb(DATA_FIFO, arg3);
        wait_for_next_param();
        outb(DATA_FIFO, arg4);
        wait_for_next_param();
        outb(DATA_FIFO, 0x02);
        wait_for_next_param();
        outb(DATA_FIFO, arg6);
        wait_for_next_param();
        outb(DATA_FIFO, 0x1b);
        wait_for_next_param();
        outb(DATA_FIFO, 0xFF);
        break;

    case WRITE_DATA:
        outb(DATA_FIFO, arg1);
        wait_for_next_param();
        outb(DATA_FIFO, arg2);
        wait_for_next_param();
        outb(DATA_FIFO, arg3);
        wait_for_next_param();
        outb(DATA_FIFO, arg4);
        wait_for_next_param();
        outb(DATA_FIFO, 0x02);
        wait_for_next_param();
        outb(DATA_FIFO, arg6);
        wait_for_next_param();
        outb(DATA_FIFO, 0x1b);
        wait_for_next_param();
        outb(DATA_FIFO, 0xFF);
        break;

    default:
        break;
    }
}

void wait_for_next_param()
{
    while (1)
    {
        if ((inb(MAIN_STATUS_REGISTER) & 0x80) == 0x80)
        {
            break;
        }
    }
}

// Commands:

/*
    First parameter unsigned char = 0
    Second parameter unsigned char = (implied seek ENable << 6) | (fifo DISable << 5) | (drive polling mode DISable << 4) | thresh_val (= threshold - 1)
    Third parameter unsigned char = precomp_val = 0
    No result unsigned chars.
    No interrupt.
*/
void configure(unsigned char impliedSeekEnable, unsigned char fifoDisable, unsigned char drivePollingDisable, unsigned char thresh_val, unsigned char precomp_val)
{
    send_command(CONFIGURE, 0, impliedSeekEnable << 6 | fifoDisable << 5 | drivePollingDisable << 4 | thresh_val, 0, 0, 0, 0);
}

/*
    Version command = 0x10
    No parameter bytes.
    No interrupt.
    First result byte = 0x90
*/
unsigned char version()
{
    send_command(VERSION, 0, 0, 0, 0, 0, 0);
    wait_for_next_param();
    return inb(DATA_FIFO);
}
/*
    Lock command = 0x94
    No parameter bytes.
    No interrupt.
    First result byte = lock bit << 4
*/
unsigned char lock()
{
    send_command(LOCK, 0, 0, 0, 0, 0, 0);
    wait_for_next_param();
    return inb(DATA_FIFO);
}

/*
    Specify command = 0x3
    First parameter byte = SRT << 4 | HUT
    Second parameter byte = HLT << 1 | NDMA
    No result bytes.
    No interrupt.
*/
void specify(unsigned char SRT, unsigned char HUT, unsigned char HLT, unsigned char NDMA)
{
    send_command(SPECIFY, SRT << 4 | HUT, HLT << 1 | NDMA, 0, 0, 0, 0);
}

/*
    Sense Interrupt command = 0x8   
    No parameter bytes.
    No interrupt.
    First result byte = st0
    Second result byte = controller's idea of the current cylinder
    Send NULL as buffer if you wanna discard the results
*/
void sense_interrupt(unsigned char *buffer)
{
    send_command(SENSE_INTERRUPT,0,0,0,0,0,0);
    if(buffer != NULL)
    {
        wait_for_next_param();
        buffer[0] = inb(DATA_FIFO);
        wait_for_next_param();
        buffer[1] = inb(DATA_FIFO);
    }
    else
    {
        wait_for_next_param();
        inb(DATA_FIFO);
        wait_for_next_param();
        inb(DATA_FIFO);
    }
}

/*
    Recalibrate command = 0x7
    First parameter byte = drive number = 0 to 3.
    No result bytes.
*/
void recalibrate()
{
    send_command(RECALIBRATE,0,0,0,0,0,0);
    wait_for_next_param();
    sense_interrupt(NULL);
}

/*
    Read command = MT bit | MFM bit | 0x6 (no MT, so 0x2400 bytes at a time, oh well)
    First parameter byte = (head number << 2) | drive number (the drive number must match the currently selected drive!)
    Second parameter byte = cylinder number
    Third parameter byte = head number
    Fourth parameter byte = starting sector number
    Fifth parameter byte = 2 (all floppy drives use 512bytes per sector)
    Sixth parameter byte = EOT (end of track, the last sector number on the track)
    Seventh parameter byte = 0x1b (GAP1 default size)
    Eighth parameter byte = 0xff (all floppy drives use 512bytes per sector)

    First result byte = st0 status register
    Second result byte = st1 status register
    Third result byte = st2 status register
    Fourth result byte = cylinder number
    Fifth result byte = ending head number
    Sixth result byte = ending sector number
    Seventh result byte = 2
*/
void readcmd(CHSAddr addr, unsigned char *buffer)
{
    send_command(READ_DATA | 0x40 , addr.head << 2 | 0, addr.cyl, addr.head, addr.sect, 2, addr.EOT);
    receivedIRQ = FALSE;
    while (!receivedIRQ)
    {
    }
    if(buffer != NULL)
    {
        wait_for_next_param();
        buffer[0] = inb(DATA_FIFO);
        wait_for_next_param();
        buffer[1] = inb(DATA_FIFO);
        wait_for_next_param();
        buffer[2] = inb(DATA_FIFO);
        wait_for_next_param();
        buffer[3] = inb(DATA_FIFO);
        wait_for_next_param();
        buffer[4] = inb(DATA_FIFO);
        wait_for_next_param();
        buffer[5] = inb(DATA_FIFO);
        wait_for_next_param();
        buffer[6] = inb(DATA_FIFO);
    }
    else
    {
        wait_for_next_param();
        inb(DATA_FIFO);
        wait_for_next_param();
        inb(DATA_FIFO);
        wait_for_next_param();
        inb(DATA_FIFO);
        wait_for_next_param();
        inb(DATA_FIFO);
        wait_for_next_param();
        inb(DATA_FIFO);
        wait_for_next_param();
        inb(DATA_FIFO);
        wait_for_next_param();
        inb(DATA_FIFO);
    }
}